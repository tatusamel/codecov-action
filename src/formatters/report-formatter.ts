import type { AggregatedCoverageResults } from "../types/coverage.js";
import type { CommentFilesMode } from "../types/config.js";
import type {
  AggregatedTestResults,
  TestComparison,
} from "../types/test-results.js";

export interface ReportFormatOptions {
  filesMode?: CommentFilesMode;
  changedFiles?: string[];
}

export class ReportFormatter {
  /**
   * Format test results and coverage as a markdown report
   */
  formatReport(
    testResults?: AggregatedTestResults,
    coverageResults?: AggregatedCoverageResults,
    options: ReportFormatOptions = {}
  ): string {
    const lines: string[] = [];

    // Main header
    lines.push("## Codecov Results üìä");
    lines.push("");

    // Add test results section
    if (testResults) {
      this.addTestResultsSection(lines, testResults);
    }

    // Add coverage section
    if (coverageResults) {
      this.addCoverageSection(lines, coverageResults, options);
    }

    // Footer
    lines.push("---");
    lines.push("*Generated by [Codecov Action](https://github.com/getsentry/codecov-action)*");

    return lines.join("\n");
  }

  /**
   * Add test results section to the report
   */
  private addTestResultsSection(
    lines: string[],
    results: AggregatedTestResults
  ): void {
    // Summary line with emoji indicators
    const passEmoji = results.passedTests > 0 ? "‚úÖ" : "";
    const failEmoji = results.failedTests > 0 ? "‚ùå" : "";
    const skipEmoji = results.skippedTests > 0 ? "‚è≠Ô∏è" : "";

    const summaryParts: string[] = [];

    if (passEmoji) {
      summaryParts.push(`${passEmoji} **${results.passedTests} passed**`);
    }
    if (failEmoji) {
      summaryParts.push(`${failEmoji} **${results.failedTests} failed**`);
    }
    if (skipEmoji) {
      summaryParts.push(`${skipEmoji} **${results.skippedTests} skipped**`);
    }

    // Add total and pass rate
    summaryParts.push(`**Total: ${results.totalTests}**`);
    summaryParts.push(`**Pass Rate: ${results.passRate}%**`);
    summaryParts.push(
      `**Execution Time: ${this.formatTime(results.totalTime)}**`
    );

    lines.push(summaryParts.join(" | "));
    lines.push("");

    // Add comparison section if available
    if (results.comparison) {
      this.addComparisonSection(lines, results.comparison);
    }

    // Show failed tests if any
    if (results.failedTests > 0 && results.failedTestCases.length > 0) {
      lines.push("### ‚ùå Failed Tests");
      lines.push("");

      for (const { suiteName, testCase } of results.failedTestCases) {
        // Test header
        lines.push(`#### \`${testCase.name}\``);
        lines.push(`**File:** \`${testCase.classname}\``);

        if (suiteName && suiteName !== testCase.classname) {
          lines.push(`**Suite:** \`${suiteName}\``);
        }

        if (testCase.failure) {
          lines.push(`**Error:** ${testCase.failure.message}`);
          lines.push("");

          // Stack trace in collapsible details
          if (testCase.failure.content) {
            lines.push("<details>");
            lines.push("<summary>Stack Trace</summary>");
            lines.push("");
            lines.push("```");
            lines.push(testCase.failure.content.trim());
            lines.push("```");
            lines.push("");
            lines.push("</details>");
            lines.push("");
          }
        }
      }
    } else if (results.failedTests === 0) {
      // Success message
      lines.push("All tests are passing successfully.");
      lines.push("");
    }

    lines.push("");
  }

  /**
   * Add coverage section to the report (Codecov-style format with icons)
   */
  private addCoverageSection(
    lines: string[],
    results: AggregatedCoverageResults,
    options: ReportFormatOptions
  ): void {
    // Calculate metrics
    const totalMissing = results.totalMisses || 0;
    // Use explicit patch coverage if available, otherwise fallback to lineRate (legacy/project)
    const patchRate =
      results.patchCoverageRate !== undefined
        ? results.patchCoverageRate.toFixed(2)
        : results.lineRate.toFixed(2);

    // Line 1: Patch coverage (emoji based on patch rate, not project misses)
    const patchEmoji = parseFloat(patchRate) >= 80 ? ":white_check_mark:" : ":x:";

    // Build message with clear separation of patch coverage and project misses
    let patchMessage = `${patchEmoji} Patch coverage is **${patchRate}%**.`;
    if (totalMissing > 0) {
      patchMessage += ` Project has **${totalMissing}** uncovered lines.`;
    }
    lines.push(patchMessage);

    // Line 2: Project coverage with comparison info
    if (results.comparison) {
      const baseRef = results.comparison.baseCommit
        ? `\`${results.comparison.baseCommit.substring(0, 7)}\``
        : "`base`";
      const headRef = results.comparison.headCommit
        ? `\`${results.comparison.headCommit.substring(0, 7)}\``
        : "`head`";
      const emoji = results.comparison.improvement
        ? ":white_check_mark:"
        : results.comparison.deltaLineRate < 0
        ? ":x:"
        : ":white_check_mark:";
      lines.push(
        `${emoji} Project coverage is **${results.lineRate}%**. Comparing base (${baseRef}) to head (${headRef}).`
      );
    }
    lines.push("");

    const filesMode = options.filesMode || "all";
    const filesWithMissing = this.getFilesWithMissingLines(results, options);

    if (filesMode !== "none" && filesWithMissing.length > 0) {
      lines.push("<details>");
      lines.push(
        `<summary>Files with missing lines (${filesWithMissing.length})</summary>`
      );
      lines.push("");
      lines.push("| File | Patch % | Lines |");
      lines.push("|------|---------|-------|");

      for (const file of filesWithMissing) {
        const fileName = this.getFileName(file.path);
        const missingCount = file.missingLines?.length || 0;
        const partialCount = file.partialLines?.length || 0;

        let linesText = "";
        if (missingCount > 0 && partialCount > 0) {
          linesText = `:warning: ${missingCount} Missing and ${partialCount} partials`;
        } else if (missingCount > 0) {
          linesText = `:warning: ${missingCount} Missing`;
        } else if (partialCount > 0) {
          linesText = `:warning: ${partialCount} partials`;
        }

        lines.push(
          `| \`${fileName}\` | ${file.lineRate.toFixed(2)}% | ${linesText} |`
        );
      }

      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Coverage diff (collapsible)
    if (results.comparison) {
      this.addDetailedCoverageDiff(lines, results);
    }

    // Flags section (collapsible)
    if (results.flags && results.flags.length > 0) {
      this.addFlagsSection(lines, results);
    }
  }

  private getFilesWithMissingLines(
    results: AggregatedCoverageResults,
    options: ReportFormatOptions
  ) {
    const allFilesWithMissing = results.files
      .filter(
        (f) =>
          (f.missingLines?.length || 0) > 0 || (f.partialLines?.length || 0) > 0
      )
      .sort((a, b) => {
        const aMissing =
          (a.missingLines?.length || 0) + (a.partialLines?.length || 0);
        const bMissing =
          (b.missingLines?.length || 0) + (b.partialLines?.length || 0);
        return bMissing - aMissing;
      });

    const filesMode = options.filesMode || "all";
    if (filesMode !== "changed") {
      return allFilesWithMissing;
    }

    const changedFiles = options.changedFiles || [];
    if (changedFiles.length === 0) {
      return [];
    }

    const changedFilesSet = new Set(
      changedFiles.map((filePath) => this.normalizeFilePath(filePath))
    );

    return allFilesWithMissing.filter((file) =>
      changedFilesSet.has(this.normalizeFilePath(file.path))
    );
  }

  private normalizeFilePath(filePath: string): string {
    return filePath.replace(/^\.?\//, "");
  }

  /**
   * Add detailed coverage diff in diff code block format (collapsible)
   */
  private addDetailedCoverageDiff(
    lines: string[],
    results: AggregatedCoverageResults
  ): void {
    const comparison = results.comparison;
    if (!comparison) return;

    const baseBranch = comparison.baseBranch || "main";
    const prLabel = "#PR";

    lines.push("<details>");
    lines.push("<summary>Coverage diff</summary>");
    lines.push("");
    lines.push("```diff");

    // Header
    lines.push("@@            Coverage Diff             @@");
    lines.push(
      `##    ${this.padCol(baseBranch, 10)}${this.padCol(
        prLabel,
        10
      )}${this.padCol("+/-", 10)}##`
    );
    lines.push("==========================================");

    // Coverage line (green if improved)
    const baseCoverage = `${(
      results.lineRate - comparison.deltaLineRate
    ).toFixed(2)}%`;
    const currentCoverage = `${results.lineRate.toFixed(2)}%`;
    const coverageDelta = `${this.formatDeltaSimple(
      comparison.deltaLineRate
    )}%`;
    const coveragePrefix = comparison.deltaLineRate >= 0 ? "+" : "-";
    lines.push(
      `${coveragePrefix} Coverage${this.padCol(baseCoverage, 10)}${this.padCol(
        currentCoverage,
        10
      )}${this.padCol(coverageDelta, 10)}`
    );

    lines.push("==========================================");

    // Neutral metrics (Files, Lines, Branches)
    const baseFiles = String(comparison.baseFiles || 0);
    const currentFiles = String(comparison.currentFiles || 0);
    const deltaFiles = this.formatDeltaSimple(comparison.deltaFiles || 0);
    lines.push(
      `  Files   ${this.padCol(baseFiles, 10)}${this.padCol(
        currentFiles,
        10
      )}${this.padCol(deltaFiles, 10)}`
    );

    const baseLines = String(comparison.baseLines || 0);
    const currentLines = String(comparison.currentLines || 0);
    const deltaLines = this.formatDeltaSimple(comparison.deltaLines || 0);
    lines.push(
      `  Lines   ${this.padCol(baseLines, 10)}${this.padCol(
        currentLines,
        10
      )}${this.padCol(deltaLines, 10)}`
    );

    const baseBranches = String(comparison.baseBranches || 0);
    const currentBranches = String(comparison.currentBranches || 0);
    const deltaBranches = this.formatDeltaSimple(comparison.deltaBranches || 0);
    lines.push(
      `  Branches${this.padCol(baseBranches, 10)}${this.padCol(
        currentBranches,
        10
      )}${this.padCol(deltaBranches, 10)}`
    );

    lines.push("==========================================");

    // Hits (green - positive indicator)
    const baseHits = String(comparison.baseHits || 0);
    const currentHits = String(comparison.currentHits || 0);
    const deltaHits = this.formatDeltaSimple(comparison.deltaHits || 0);
    lines.push(
      `+ Hits    ${this.padCol(baseHits, 10)}${this.padCol(
        currentHits,
        10
      )}${this.padCol(deltaHits, 10)}`
    );

    // Misses (red - negative indicator)
    const baseMisses = String(comparison.baseMisses || 0);
    const currentMisses = String(comparison.currentMisses || 0);
    const deltaMisses = this.formatDeltaSimple(comparison.deltaMisses || 0);
    lines.push(
      `- Misses  ${this.padCol(baseMisses, 10)}${this.padCol(
        currentMisses,
        10
      )}${this.padCol(deltaMisses, 10)}`
    );

    // Partials (red - negative indicator)
    const basePartials = String(comparison.basePartials || 0);
    const currentPartials = String(comparison.currentPartials || 0);
    const deltaPartials = this.formatDeltaSimple(comparison.deltaPartials || 0);
    lines.push(
      `- Partials${this.padCol(basePartials, 10)}${this.padCol(
        currentPartials,
        10
      )}${this.padCol(deltaPartials, 10)}`
    );

    lines.push("```");
    lines.push("");
    lines.push("</details>");
    lines.push("");
  }

  /**
   * Pad a column value for alignment
   */
  private padCol(value: string, width: number): string {
    return value.padStart(width);
  }

  /**
   * Add flags section (collapsible)
   */
  private addFlagsSection(
    lines: string[],
    results: AggregatedCoverageResults
  ): void {
    if (!results.flags || results.flags.length === 0) return;

    lines.push("<details>");
    lines.push(`<summary>Flags (${results.flags.length})</summary>`);
    lines.push("");

    for (const flag of results.flags) {
      const coverageChange = results.comparison
        ? ` (${this.formatCoverageDelta(results.comparison.deltaLineRate)}%)`
        : "";
      lines.push(`- \`${flag}\`: ${results.lineRate}%${coverageChange}`);
    }
    lines.push("");
    lines.push("</details>");
    lines.push("");
  }

  /**
   * Get just the filename from a path
   */
  private getFileName(path: string): string {
    return path.split("/").pop() || path;
  }

  /**
   * Format delta value with sign only (no emoji)
   */
  private formatDeltaSimple(delta: number): string {
    if (delta === 0) return "‚Äî";
    const sign = delta > 0 ? "+" : "";
    return `${sign}${delta}`;
  }

  /**
   * Add comparison section to the report
   */
  private addComparisonSection(
    lines: string[],
    comparison: TestComparison
  ): void {
    lines.push("### üìä Comparison with Base Branch");
    lines.push("");

    // Summary table
    lines.push("| Metric | Change |");
    lines.push("|--------|--------|");
    lines.push(`| Total Tests | ${this.formatDelta(comparison.deltaTotal)} |`);
    lines.push(
      `| Passed Tests | ${this.formatDelta(comparison.deltaPassed)} |`
    );
    lines.push(
      `| Failed Tests | ${this.formatDelta(comparison.deltaFailed)} |`
    );
    lines.push(
      `| Skipped Tests | ${this.formatDelta(comparison.deltaSkipped)} |`
    );
    lines.push("");

    // Tests broken (regressions)
    if (comparison.testsBroken.length > 0) {
      lines.push(`#### üî¥ Tests Broken (${comparison.testsBroken.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View broken tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsBroken) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
        if (testChange.testCase.failure) {
          lines.push(`  - **Error:** ${testChange.testCase.failure.message}`);
        }
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests fixed (improvements)
    if (comparison.testsFixed.length > 0) {
      lines.push(`#### üü¢ Tests Fixed (${comparison.testsFixed.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View fixed tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsFixed) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests added
    if (comparison.testsAdded.length > 0) {
      lines.push(`#### ‚ûï New Tests (${comparison.testsAdded.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View new tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsAdded) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
        if (testChange.testCase.failure) {
          lines.push(`  - **Status:** ‚ùå Failing`);
        } else {
          lines.push(`  - **Status:** ‚úÖ Passing`);
        }
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests removed
    if (comparison.testsRemoved.length > 0) {
      lines.push(`#### ‚ûñ Removed Tests (${comparison.testsRemoved.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View removed tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsRemoved) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Summary message
    if (
      comparison.testsBroken.length === 0 &&
      comparison.testsFixed.length === 0 &&
      comparison.testsAdded.length === 0 &&
      comparison.testsRemoved.length === 0 &&
      comparison.deltaTotal === 0
    ) {
      lines.push("‚ú® No test changes detected");
      lines.push("");
    }
  }

  /**
   * Format a delta value with appropriate sign and emoji
   */
  private formatDelta(delta: number): string {
    if (delta === 0) {
      return "‚Äî";
    }
    const sign = delta > 0 ? "+" : "";
    const emoji = delta > 0 ? "üìà" : "üìâ";
    return `${emoji} ${sign}${delta}`;
  }

  /**
   * Format a coverage delta value with appropriate sign
   */
  private formatCoverageDelta(delta: number): string {
    if (delta === 0) {
      return "¬±0.00";
    }
    const sign = delta > 0 ? "+" : "";
    return `${sign}${delta.toFixed(2)}`;
  }

  /**
   * Format execution time in a human-readable way
   */
  private formatTime(seconds: number): string {
    if (seconds < 1) {
      return `${Math.round(seconds * 1000)}ms`;
    }
    if (seconds < 60) {
      return `${seconds.toFixed(2)}s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
  }

  /**
   * Generate a unique identifier for the comment
   * This helps identify comments created by this action
   */
  static getCommentIdentifier(): string {
    return "<!-- codecov-action-results -->";
  }

  /**
   * Legacy identifier for backward compatibility
   */
  static getLegacyCommentIdentifier(): string {
    return "<!-- codecov-action-test-results -->";
  }

  /**
   * Add identifier to comment body
   */
  addIdentifier(comment: string): string {
    return `${ReportFormatter.getCommentIdentifier()}\n${comment}`;
  }
}
