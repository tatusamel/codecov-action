import type {
  CoverageMetrics,
  CoverageResults,
  FileCoverage,
  LineCoverage,
} from "../types/coverage.js";
import { BaseCoverageParser, type CoverageFormat } from "./base-parser.js";

/**
 * Parser for Go coverage profile format
 * Generated by: go test -coverprofile=coverage.out
 *
 * Format structure:
 * mode: set|count|atomic
 * github.com/user/project/pkg/file.go:10.2,12.16 1 1
 * github.com/user/project/pkg/file.go:14.2,15.16 1 0
 *
 * Each line after mode: <filename>:<startLine>.<startCol>,<endLine>.<endCol> <numStatements> <count>
 *
 * Modes:
 * - set: Was this statement run? (0 or 1)
 * - count: How many times was this statement run?
 * - atomic: Thread-safe counting
 */
export class GoParser extends BaseCoverageParser {
  readonly format: CoverageFormat = "go";

  /**
   * Check if content is Go coverage profile format
   */
  canParse(content: string, filePath?: string): boolean {
    // Check file extension
    if (filePath) {
      const ext = this.getFileExtension(filePath);
      const fileName = filePath.toLowerCase();
      if (
        fileName.endsWith("coverage.out") ||
        fileName.endsWith("cover.out") ||
        fileName.endsWith(".coverprofile") ||
        ext === "out"
      ) {
        return true;
      }
    }

    // Check content structure - Go coverage starts with "mode:"
    const lines = content.trim().split("\n");
    if (lines.length === 0) {
      return false;
    }

    const firstLine = lines[0].trim();
    if (
      firstLine.startsWith("mode:") &&
      (firstLine.includes("set") ||
        firstLine.includes("count") ||
        firstLine.includes("atomic"))
    ) {
      return true;
    }

    // Check for Go coverage line format
    // e.g., github.com/user/proj/file.go:10.2,12.16 1 1
    const goCoverageLinePattern = /^[\w./\\-]+\.go:\d+\.\d+,\d+\.\d+ \d+ \d+$/;
    for (const line of lines.slice(0, 5)) {
      if (goCoverageLinePattern.test(line.trim())) {
        return true;
      }
    }

    return false;
  }

  /**
   * Parse Go coverage profile content
   */
  async parseContent(content: string): Promise<CoverageResults> {
    const lines = content.trim().split("\n");

    // Skip mode line if present
    let dataLines = lines;
    if (lines[0]?.trim().startsWith("mode:")) {
      dataLines = lines.slice(1);
    }

    // Group coverage blocks by file
    const fileBlocks: Map<
      string,
      Array<{
        startLine: number;
        startCol: number;
        endLine: number;
        endCol: number;
        numStmts: number;
        count: number;
      }>
    > = new Map();

    for (const line of dataLines) {
      const trimmed = line.trim();
      if (!trimmed) continue;

      const parsed = this.parseCoverageLine(trimmed);
      if (!parsed) continue;

      if (!fileBlocks.has(parsed.file)) {
        fileBlocks.set(parsed.file, []);
      }
      fileBlocks.get(parsed.file)!.push(parsed.block);
    }

    // Convert to FileCoverage
    const files: FileCoverage[] = [];
    let totalStatements = 0;
    let coveredStatements = 0;

    for (const [filePath, blocks] of fileBlocks.entries()) {
      const fileResult = this.parseFileBlocks(filePath, blocks);
      files.push(fileResult);

      totalStatements += fileResult.statements;
      coveredStatements += fileResult.coveredStatements;
    }

    const metrics: CoverageMetrics = {
      statements: totalStatements,
      coveredStatements,
      conditionals: 0, // Go coverage doesn't track branches separately
      coveredConditionals: 0,
      methods: 0, // Go coverage doesn't track functions separately
      coveredMethods: 0,
      elements: totalStatements,
      coveredElements: coveredStatements,
      lineRate: this.calculateRate(coveredStatements, totalStatements),
      branchRate: 0,
    };

    return {
      timestamp: Date.now(),
      metrics,
      files,
    };
  }

  /**
   * Parse a single coverage line
   * Format: file.go:startLine.startCol,endLine.endCol numStmts count
   */
  private parseCoverageLine(line: string):
    | {
        file: string;
        block: {
          startLine: number;
          startCol: number;
          endLine: number;
          endCol: number;
          numStmts: number;
          count: number;
        };
      }
    | null {
    // Match: file.go:10.2,12.16 1 5
    const match = line.match(
      /^(.+\.go):(\d+)\.(\d+),(\d+)\.(\d+) (\d+) (\d+)$/
    );
    if (!match) {
      return null;
    }

    return {
      file: match[1],
      block: {
        startLine: Number.parseInt(match[2], 10),
        startCol: Number.parseInt(match[3], 10),
        endLine: Number.parseInt(match[4], 10),
        endCol: Number.parseInt(match[5], 10),
        numStmts: Number.parseInt(match[6], 10),
        count: Number.parseInt(match[7], 10),
      },
    };
  }

  /**
   * Convert file blocks to FileCoverage
   */
  private parseFileBlocks(
    filePath: string,
    blocks: Array<{
      startLine: number;
      startCol: number;
      endLine: number;
      endCol: number;
      numStmts: number;
      count: number;
    }>
  ): FileCoverage {
    const fileName = filePath.split("/").pop() || filePath;

    // Calculate total statements and covered
    let totalStatements = 0;
    let coveredStatements = 0;

    // Build line coverage
    const lineMap: Map<number, number> = new Map();

    for (const block of blocks) {
      totalStatements += block.numStmts;
      if (block.count > 0) {
        coveredStatements += block.numStmts;
      }

      // Mark all lines in the block
      for (let line = block.startLine; line <= block.endLine; line++) {
        const existing = lineMap.get(line) || 0;
        lineMap.set(line, Math.max(existing, block.count));
      }
    }

    // Convert to LineCoverage array
    const lines: LineCoverage[] = [];
    for (const [lineNum, count] of lineMap.entries()) {
      lines.push({
        lineNumber: lineNum,
        count,
        type: "stmt",
      });
    }

    // Sort by line number
    lines.sort((a, b) => a.lineNumber - b.lineNumber);

    return {
      name: fileName,
      path: filePath,
      statements: totalStatements,
      coveredStatements,
      conditionals: 0,
      coveredConditionals: 0,
      methods: 0,
      coveredMethods: 0,
      lineRate: this.calculateRate(coveredStatements, totalStatements),
      branchRate: 0,
      lines,
    };
  }
}
